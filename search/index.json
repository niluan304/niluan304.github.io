[{"content":" 源代码/数据集已上传到：GitHub - follow gee to learn go\nGoFrame 的 ReqResFunc 类型 在 day7.5 开篇的时候，笔者提到 GoFrame 支持第二种路由注册方法，这里笔者称之为 ReqResFunc 类型（下文同）：\n// 写法二 func (ctx context.Context, req *{Prefix}Req) (res *{Prefix}Res, err error){ // 业务代码逻辑 } 但是 day9 实现的函数签名：\nfunc (c *user) Get(ctx context.Context, bind func(point any) (err error)) (data any, err error) 对比可以发现，和 ReqResFunc 类型有明显不同，我们可以在 GoFrame 的源码里一探究竟。\n从 GoFrame 的 文档「路由注册-函数注册」中，可以找到 入口函数：\n// https://github.com/gogf/gf/blob/313d9d138f96b0ed460d47684298a7fb26d3fd75/net/ghttp/ghttp_server_service_handler.go#L21-L39 // BindHandler registers a handler function to server with a given pattern. // // Note that the parameter `handler` can be type of: // 1. func(*ghttp.Request) // 2. func(context.Context, BizRequest)(BizResponse, error) func (s *Server) BindHandler(pattern string, handler interface{}) { var ctx = context.TODO() funcInfo, err := s.checkAndCreateFuncInfo(handler, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { s.Logger().Fatalf(ctx, `%+v`, err) } s.doBindHandler(ctx, doBindHandlerInput{ Prefix: \u0026#34;\u0026#34;, Pattern: pattern, FuncInfo: funcInfo, Middleware: nil, Source: \u0026#34;\u0026#34;, }) } 在源码里，可以发现关键代码在 checkAndCreateFuncInfo 方法，继续前行，就能够发现端倪：\n// https://github.com/gogf/gf/blob/313d9d138f96b0ed460d47684298a7fb26d3fd75/net/ghttp/ghttp_server_service_handler.go#L148 func (s *Server) checkAndCreateFuncInfo(f interface{}, pkgPath, structName,methodName string,) (funcInfo handlerFuncInfo, err error) { funcInfo = handlerFuncInfo{ // 根据传入的 f，初始化返回值 Type: reflect.TypeOf(f), Value: reflect.ValueOf(f), } } GoFrame 通过反射 reflect，获取了传入的函数的参数信息，并做了相应的校验，关键代码有 5 行：\n// 校验请求和返回的参数数量 if reflectType.NumIn() != 2 || reflectType.NumOut() != 2 // 第一个请求参数必须为 context.Context 类型 if !reflectType.In(0).Implements(reflect.TypeOf((*context.Context)(nil)).Elem()) // 第二个返回参数必须为 error 类型 if !reflectType.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) // 第二个请求参数必须为以 `Req` 结尾 if !strings.HasSuffix(reflectType.In(1).String(), `Req`) // 第一个返回参数必须为以 `Res` 结尾 if !strings.HasSuffix(reflectType.Out(0).String(), `Res`) 通过这些校验，GoFrame 就实现了规范路由函数必须是 ResReqFunc 类型的约束。校验过程中，有一些细节：\nctx 和 error 是接口类型，只能调用 func (Type) Implements(u Type) bool 确认是否实现了对应的接口，(*error)(nil) 和 (*context.Context)(nil) 则是声明了对应接口的空值 nil。 req 和 res 的初始类型是结构体，可以直接获取结构体的。 实现 ReqResFunc 类型的约束 接下来，我们就可以仿照 GoFrame，实现 ResReqFunc 类型的约束。首先需要创建一个结构体，用于保存反射解析出来的值：\ntype ReqResFunc struct { fn reflect.Value // 函数调用入口 ctx reflect.Type // 第一个请求参数：context.Context req reflect.Type // 第二个请求参数：XXXReq res reflect.Type // 第一个返回参数：XXXRes err reflect.Type // 第二个返回参数：error } 具体的解析代码，可以全部仿照 GoFrame 的流程，获取入参 reqRes 的反射对象，然后逐个校验，最后再构造 ReqResFunc。\n那么还剩最后一个问题， ReqResFunc 要注册到 gin框架里呢？这里和 day9 遇到的情况一样，想让两个不兼容的接口，能够一起工作，就需要一个中间函数：\nfunc ReqResHandle(reqResFunc any) gin.HandlerFunc { f := NewReqResFunc(reqResFunc) return func(c *gin.Context) { req := reflect.New(f.req).Interface() // 使用 reflect.New 初始化变量 if err := c.ShouldBindJSON(req); err != nil { c.JSON(http.StatusOK, Response{Code: 400, Msg: err.Error(), Data: nil}) return } result := f.fn.Call([]reflect.Value{reflect.ValueOf(c), reflect.ValueOf(req).Elem()}) if err := result[1]; !err.IsNil() { c.JSON(http.StatusOK, Response{Code: 400, Msg: err.Interface().(error).Error(), Data: nil}) } c.JSON(http.StatusOK, result[0].Interface()) } } 而 GoFrame 也是这样转化的，相关源码： func createRouterFunc(funcInfo handlerFuncInfo) func(r *Request)\n验证 ReqResFunc 类型 增加了一个新特性，那必然是需要测试的，这里可以新建 Upsert 接口（如果不存在就新增，存在就更新）用于测试：\nfunc (c *user) Upsert(ctx context.Context, req *UserUpsertReq) (res *UserUpsertRes, err error) { // 尝试更新数据 update, err := service.User.Update(ctx, \u0026amp;service.UserUpdateReq{Name: req.Name, Age: req.Age, Job: req.Job}) if err != nil { return nil, err } if update != nil { return \u0026amp;UserUpsertRes{Name: update.Name, Age: update.Age, Job: update.Job}, nil } // 数据不存在则新增 // TODO 更新数据不存在时，应当返回自定义类型的错误，而不是通过 nil 判断 _, err = service.User.Add(ctx, \u0026amp;service.UserAddReq{Name: req.Name, Age: req.Age, Job: req.Job}) if err != nil { return nil, err } return nil, nil } 代码实现很简单，先调用 service.User.Update，如果 update == nil 就表示更新失败，数据库未找到这条数据。然后再执行数据插入 service.User.Add 的操作。当然，主流的数据库里都有类似的语法实现 Upsert，如 MySQL 和 Postgres。\n但这并不是重点，我们应该聚焦于新接口 *user.Upsert 本身，他只调用两个已有的业务方法就完成自身的工作，这解决了 day8 提到的「代码难以复用」的问题：\n假如随着项目的进展，导致 Add 部分业务代码和 Get 的完全一致，甚至最好的解决办法是直接调用 Get 方式，但这没办法真的去调用 Get 方式，因为 Add 接收到的 *gin.Context 与 Get 方法需要的 *gin.Context 是有差别的。\n测试接口：\nfunc client() { time.Sleep(time.Second) // 等待路由注册 reqs := []func(host string) (*http.Response, error){ func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Bob\u0026#34;) }, func(host string) (*http.Response, error) { return http.Post(host+\u0026#34;/user\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBufferString(`{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}`)) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, // 测试 upsert 接口 func(host string) (*http.Response, error) { return http.Post(host+\u0026#34;/user/upsert\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBufferString(`{\u0026#34;name\u0026#34;:\u0026#34;Dave\u0026#34;,\u0026#34;age\u0026#34;:32,\u0026#34;job\u0026#34;:\u0026#34;nurse\u0026#34;}`)) }, func(host string) (*http.Response, error) { return http.Post(host+\u0026#34;/user/upsert\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBufferString(`{\u0026#34;name\u0026#34;:\u0026#34;Dave\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;job\u0026#34;:\u0026#34;doctor\u0026#34;}`)) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Dave\u0026#34;) }, } for _, req := range reqs { resp, err := req(\u0026#34;http://localhost:8080\u0026#34;) if err != nil { fmt.Println(\u0026#34;req err\u0026#34;, err) } data, err := io.ReadAll(resp.Body) if err != nil { fmt.Println(\u0026#34;read resp.Body err\u0026#34;, err) } fmt.Println(string(data)) } // Output: // // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;job\u0026#34;:\u0026#34;driver\u0026#34;}} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Dave\u0026#34;,\u0026#34;age\u0026#34;:32,\u0026#34;job\u0026#34;:\u0026#34;nurse\u0026#34;}} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Dave\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;job\u0026#34;:\u0026#34;doctor\u0026#34;}} } 从新增的请求的结果来看，实现了先插入了 Dave 为 nurse 的数据，后面将 Dave 修改了 doctor，符合预期，说明 ReqResFunc 类型测试通过。\n通过对象注册路由 事实上，GoFrame 还有第三种路由注册方法：对象注册，向 *(ghttp.RouterGroup).Bind 传入一个结构体变量，然后 GoFrame 会尝试注册这个结构体上的所有 ReqResFunc 类型的方法。这也是通过反射实现的，核心代码也很简短：\nfunc ObjectHandler(object any) (handles []gin.HandlerFunc) { v := reflect.ValueOf(object) // 如果是结构体, 那么获取这个结构体的指针, 从而遍历到他的所有方法 if v.Kind() == reflect.Struct { newValue := reflect.New(v.Type()) newValue.Elem().Set(v) v = newValue } if v.Kind() != reflect.Pointer { panic(\u0026#34;v.Kind() must be reflect.Pointer\u0026#34;) } t := v.Type() for i := 0; i \u0026lt; t.NumMethod(); i++ { fn := v.MethodByName(t.Method(i).Name) // 所有方法都必须为 ReqResFunc 类型 handles = append(handles, ReqResHandle(fn.Interface())) } return handles } 通过对象注册路由有个缺点，难以为 HandlerFunc 绑定 path 和 method。GoFrame 的解决方式是在 Req（第二个请求参数）里写 go tag，有兴趣的读者，可以察看「文档：规范参数结构」或自己实现（GoFrame 源码参考。\n","date":"2023-12-22T15:43:59+08:00","permalink":"https://niluan304.github.io/p/gee-web-day10-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9E%84%E9%80%A0%E8%A7%84%E8%8C%83%E8%B7%AF%E7%94%B1/","title":"gee-web-day10 通过反射构造规范路由"},{"content":" 源代码/数据集已上传到：GitHub - follow gee to learn go\n经过分层处理后，项目布局有了很大改善，但是仍然存在问题。\ncontroller 层的错误处理代码特别繁琐，有太多的：ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) controller 层只支持 gin 框架，更不支持其他协议 让调用者帮忙反序列化 观察 controller 层可以得出一个结论：controller 的需求其实很简单：反序列化为 service 层所需要 go 类型，并在 err != nil 时做控制的流转。\n那么该怎么实现呢？这其实并不难。\n不知道是否有读者会好奇 Get 方法里的搜索函数：\n// ./day8/internal/service/user.go i := slices.IndexFunc(database, func(row Row) bool { return row.Name == req.Name }) 只需要往 slices.IndexFunc 传入了一个闭包，就可以等待函数返回所在值的索引，slices.IndexFunc的实现，也同样简单：\n// std: slices/slices.go // IndexFunc returns the first index i satisfying f(s[i]), // or -1 if none do. func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int { for i := range s { if f(s[i]) { return i } } return -1 } 但让我们换个角度思考，对于 slices.IndexFunc 来说，它并不关心 s 里的元素，只关心 f(s[i]) 的结果，因此只需要调用传入的闭包，就完成了任务。同样地，对于 controller 层来说，只关心反序列化 var req service.UserGetReq。那么能否仿照 slices.IndexFunc 让外部传入一个闭包，让闭包帮 controller 层反序列化 req呢？答案是可以的，只需要修改 controller 的入参为：\nfunc (c *user) Get( ctx context.Context, // 第一个参数：ctx bind func(point any) (err error), // 第二个参数：用于反序列化的闭包 ) ( data any, // 返回的数据 err error, // 错误处理 ){ var req service.UserGetReq err = bind(\u0026amp;req) // 通过闭包反序列化 req if err != nil { return nil, err } res, err := service.User.Get(ctx, req) if err != nil { return nil, err } return res, nil } 经过改动的 controller 和 web框架彻底解耦了，完全看不到 gin 框架的代码，毕竟反序列化的工作也并不是 controller 的任务，错误处理和数据返回也变得非常简单，只需要抛给上层处理（要么 return nil, err，要么 return res, nil），解耦之后也为 controller 层兼容多种协议带来了可能。\n不过但也带来了一个问题：这样的函数，该如何注册到 gin框架里呢？\n统一错误处理和数据返回 阐述这部分内容之前，笔者想简单的介绍一下「设计模式」里的「适配器模式」1：\n简单来讲，就是通过接口转换，让两个不兼容的接口，能够一起工作，现实中的经典例子： 和上面的图片类似，修改后的函数类型已经和框架要求的 gin.HandlerFunc 截然不同，但借鉴适配器模式的思想，通过中间函数转化，就可以了：\n// ./handle/handle.go // 设置为类型，用于优化参数显示 type BinderFunc = func( ctx context.Context, // 第一个参数：ctx bind func(point any) (err error), // 第二个参数：用于反序列化的闭包 ) ( data any, // 返回的数据 err error, // 错误处理 ) func Handle(binder BinderFunc) gin.HandlerFunc { return func(c *gin.Context) { data, err := binder(c, func(point any) (err error) { // 实现反序列化 return c.ShouldBind(point) }) if err != nil { c.JSON(http.StatusOK, Response{Code: 400, Msg: err.Error(), Data: nil}) return } c.JSON(http.StatusOK, Response{200, \u0026#34;\u0026#34;, data}) } } 新的函数作为「适配器」，也会被其他路由调用，也不是业务相关的内容，不适合放到 internal 包，应当放到新的包（文件夹）里，笔者将之保存至 /handle/handle.go。\n相应地，路由注册也有些变化：\nfunc main() { r := gin.Default() { user := r.Group(\u0026#34;/user\u0026#34;) user.GET(\u0026#34;/\u0026#34;, handle.Handle(controller.User.Get)) user.POST(\u0026#34;/\u0026#34;, handle.Handle(controller.User.Add)) } r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) } 对比 day8 的注册模式：\nuser.GET(\u0026#34;/\u0026#34;, controller.User.Get) // 函数签名：func (c *user) Get(ctx *gin.Context) user.POST(\u0026#34;/\u0026#34;, controller.User.Add) // 函数签名：func (c *user) Add(ctx *gin.Context) 虽然注册路由时，必须得借用 handle.Handle 才能转化为 gin.HandlerFunc，但是可以不用在 controller层里写 c.JSON(http.StatusOK, Response{Code: 400, Msg: err.Error(), Data: nil}) 和 c.JSON(http.StatusOK, Response{200, \u0026quot;\u0026quot;, data}) 了。至此，我们就完成了错误处理和数据返回的统一。\n小结 本章节主要做了两件事：\ncontroller 层通过传入 binder 闭包，调用闭包实现反序列化出 service 层所需数据，也完成了 controller 与框架的解耦，日后可以兼容其他框架（如 echo）和其他协议（如 rpc）。 借鉴适配器模式，将 binderFunc 函数转化为框架所需要的类型，并实现错误处理和数据返回的统一。 运行结果也没有变化：\nfunc client() { time.Sleep(time.Second) // 等待路由注册 reqs := []func(host string) (*http.Response, error){ func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Bob\u0026#34;) }, func(host string) (*http.Response, error) { return http.Post(host+\u0026#34;/user\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBufferString(`{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}`)) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, } for _, req := range reqs { resp, err := req(\u0026#34;http://localhost:8080\u0026#34;) if err != nil { fmt.Println(\u0026#34;req err\u0026#34;, err) } data, err := io.ReadAll(resp.Body) if err != nil { fmt.Println(\u0026#34;read resp.Body err\u0026#34;, err) } fmt.Println(string(data)) } // Output: // // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;job\u0026#34;:\u0026#34;driver\u0026#34;}} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}} } 适配器模式\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-12-21T18:15:11+08:00","permalink":"https://niluan304.github.io/p/gee-web-day9-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E8%A7%A3%E8%80%A6/","title":"gee-web-day9 反序列化与解耦"},{"content":" 源代码/数据集已上传到：GitHub - follow gee to learn go\n什么是请求分层流转 在阐述为什么需要分层设计之前，笔者想先介绍一下分层流转1：\n分层之后，可以让每一个函数只负责一件事，这类似于设计模式里单一职责的思想，可以提高项目的可维护性，与接口的可复用性。\n代码纠缠的困境 这里有一份简单的 CURD 代码，目前只有两个功能，Add, Get：\ntype Response struct { Code int // 业务代码，200 表示 OK，其他表示错误 Msg string // 错误消息 database any // 返回的数据 } type Row struct { Name string Age int Job string } // database 只是一个切片 []Row，用于充当数据库 var database = []Row{ {\u0026#34;Alice\u0026#34;, 32, \u0026#34;teacher\u0026#34;}, {\u0026#34;Bob\u0026#34;, 30, \u0026#34;driver\u0026#34;} } var User = \u0026amp;user{} type user struct{} func (c *user) Add(ctx *gin.Context) { var req Row err := ctx.ShouldBind(\u0026amp;req) // 请求数据的反序列化 if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } // 插入数据，database 只是一个切片 []Row，用于充当数据库 database = append(database, req) // 填写响应内容 ctx.JSON(http.StatusOK, Response{200, \u0026#34;\u0026#34;, nil}) return } func (c *user) Get(ctx *gin.Context) { var req Row err := ctx.ShouldBind(\u0026amp;req) if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } // 查询数据，database 只是一个切片 []Row，用于充当数据库 i := slices.IndexFunc(database, func(row Row) bool { return row.Name == req.Name }) if i != -1 { // 填写响应内容 ctx.JSON(http.StatusOK, Response{200, \u0026#34;\u0026#34;, database[i]}) } return } 看起来没什么问题，但假如随着项目的进展，导致 Add 部分业务代码和 Get 的完全一致，甚至最好的解决办法是直接调用 Get 方式，但这没办法真的去调用 Get 方式，因为 Add 接收到的 *gin.Context 与 Get 方法需要的 *gin.Context 是有差别的。\n这时候就可以进行分层设计，现在比较流行的纯后端 API 模块一般采用下述划分方法2\nController，与上述类似，服务入口，负责处理路由，参数校验，请求转发。 Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的。业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为 Business Rules。 DAO/Repository，这一层主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式暴露给 Logic 层来使用。负责数据的持久化工作。 分层设计 先介绍下分层后的目录结构：\n. |-- go.mod |-- go.sum |-- internal | |-- controller | | `-- user.go | `-- service | |-- user.go | `-- user_model.go `-- main.go 当业务代码都放到了 service 层时，这一层的代码互相调用是不会被 controller 层影响的，这也实现了 gin 框架与业务代码的解耦。\ncontroller 层的主要代码：\n// ./internal/controller/user.go func (c *user) Add(ctx *gin.Context) { // 请求数据的反序列化 var req *service.UserAddReq err := ctx.ShouldBind(\u0026amp;req) if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } res, err := service.User.Add(ctx, req) if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } // 填写响应内容 ctx.JSON(http.StatusOK, Response{200, \u0026#34;\u0026#34;, res}) return } func (c *user) Get(ctx *gin.Context) { var req *service.UserGetReq err := ctx.ShouldBind(\u0026amp;req) if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } res, err := service.User.Get(ctx, req) if err != nil { ctx.JSON(http.StatusOK, Response{400, err.Error(), nil}) return } // 填写响应内容 ctx.JSON(http.StatusOK, Response{200, \u0026#34;\u0026#34;, res}) return } service 层的主要代码：\n// ./internal/service/user.go func (s *user) Add(ctx context.Context, req *UserAddReq) (res *UserAddRes, err error) { // 插入数据 database = append(database, Row{req.Name, req.Age, req.Job}) return } func (s *user) Get(ctx context.Context, req *UserGetReq) (res *UserGetRes, err error) { // 查询数据 i := slices.IndexFunc(database, func(row Row) bool { return row.Name == req.Name }) if i != -1 { // 填写响应内容 row := database[i] return \u0026amp;UserGetRes{Name: row.Name, Age: row.Age, Job: row.Job}, nil } return } 分层后的总代码行数有所增加，甚至 controller 错误处理变得更繁琐了，但是整个项目的布局变得更清晰了，业务代码也不会受到 web框架的干扰，可以集中处理业务。\n更可贵的是，service 层的方法在调用时，就可以知道所需要的参数，以及返回的值。不过有些读者可能会有疑问，为什么 service 层方法的第一个参数都是 ctx context.Context，即便代码中未必使用，这算是 go 语言在 web 开发中的特色（也可能是技术债），用于并发控制和上下文信息传递的，有兴趣可以自行了解下。\n小结 本章节介绍下「分层设计」与「单一职责」的联系，并说明如何通过分层设计将业务代码与 web框架解耦。\n注意：分层设计也会导致一个问题：新增一个业务接口时，需要改动的文件也会变多，不过这可以通过脚本生成代码缓解。 最后让我们来看看程序的运行结果：\nfunc client() { time.Sleep(time.Second) // 等待路由注册 reqs := []func(host string) (*http.Response, error){ func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Bob\u0026#34;) }, func(host string) (*http.Response, error) { return http.Post(host+\u0026#34;/user\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBufferString(`{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}`)) }, func(host string) (*http.Response, error) { return http.Get(host + \u0026#34;/user?name=Carol\u0026#34;) }, } for _, req := range reqs { resp, err := req(\u0026#34;http://localhost:8080\u0026#34;) if err != nil { fmt.Println(\u0026#34;req err\u0026#34;, err) } data, err := io.ReadAll(resp.Body) if err != nil { fmt.Println(\u0026#34;read resp.Body err\u0026#34;, err) } fmt.Println(string(data)) } // Output: // // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;job\u0026#34;:\u0026#34;driver\u0026#34;}} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:null} // {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Carol\u0026#34;,\u0026#34;age\u0026#34;:44,\u0026#34;job\u0026#34;:\u0026#34;worker\u0026#34;}} } 工程目录设计🔥 - GoFrame (ZH)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n大型Web项目分层 - Go语言高级编程：\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-12-20T13:49:08+08:00","permalink":"https://niluan304.github.io/p/gee-web-day8-%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/","title":"gee-web-day8 分层设计的必要性"},{"content":"跟着这篇教程 7天用Go从零实现Web框架Gee教程 | 极客兔兔，笔者实现了一个简单的 web框架，从而明白了 web框架所需要的特性，还迸发出封装 gin 的想法。\nweb框架 所需要的特性 分组控制 分组控制 (Group Control)是 Web 框架应当提供的基础功能，有了分组与分组嵌套，系统才可以更方便的管理不同的业务，搭配中间件，就可以处理同组下的公共逻辑。\n中间件 中间件 (Middleware)是 web 框架的灵魂，为 web 框架提供无限的扩展能力。有了中间件，可以只对 admin 和 api 分组进行鉴权，对特定接口限流。对最顶层目录 \u0026ldquo;/\u0026quot;，也就是整个系统，可以配置日志，请求耗时等功能。\n动态路由 动态路由 (Dynamic Route)，本质上只是将参数给映射为路径的一部分了，比如 https://github.com/niluan304 和 https://github.com/?user=niluan304 对于后端来讲并没有什么不同。不过动态路由还是有优势的：\n提高SEO：搜索引擎解析静态URL更为轻松，动态路由将参数内嵌至URL中，可以提高SEO效果。 可读性和可维护性：现阶段的动态路由可以有多个参数，如 /user/:name/article/:articleId，可读性和可维护性明显高于 user/article?name=zwei\u0026amp;?articleId=1234。 可拓展性：动态路由可以使用前缀进行分组，这样可以很容易添加和修改同一分组下的中间件。 gin 与 GoFrame 的差异 实现简易web框架之后，才算理解 gin 的中间件与业务代码的格式为什么必须为：\nfunc(c *gin .Context) { // 中间件 或 业务代码逻辑 } 但是这和笔者最熟悉的 GoFrame 框架有一些差异，GoFrame 还额外支持另一种写法：\n// 中间件式写法，类似 gin 的 func(c *gin .Context) func (r *ghttp.Request) { // 中间件 或 业务代码逻辑 } // 写法二 func (ctx context.Context, req *{Prefix}Req) (res *{Prefix}Res, err error){ // 业务代码逻辑 } 带着疑问，笔者探究了两个框架之间的差异，并尝试将 gin 的接口改造为 GoFrame 格式。 总结后可以概括为三个部分，这算是「7天教程」的读后感，笔者也仿照命名为：\nday8 分层设计的必要性 day9 反序列化与解耦 day10 通过反射构造规范路由 ","date":"2023-12-19T11:27:57+08:00","permalink":"https://niluan304.github.io/p/gee-web-day7.5-7%E5%A4%A9-web%E6%A1%86%E6%9E%B6%E8%AF%BB%E5%90%8E%E6%84%9F/","title":"gee-web-day7.5 「7天 web框架」读后感"},{"content":"在国内执行 git clone https://github.com/golang/go.git 操作，又慢又不稳定，搜索后发现可以使用代理这个问题。\n准备工作 首先，你需要准备好代理工具，一般的代理工具都有 Sock5 和 HTTP 两种代理方式。\n常见的代理软件使用的端口有：7890, 1080，下文的 {port} 参数都需要修改为对应的端口号。\n笔者会按照 Windows 和 类 Unix 系统介绍为 git 设置代理的方法，由于相似处很多，请按需查看。\nWindows 下 为 HTTP 协议设置代理 在 GitHub上，通过第一种方式克隆仓库，这里走的就是 HTTP 协议，修改起来也很简单：\n命令行设置 通过代理软件 HTTP 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy socks5://127.0.0.1:{port} 可以发现，两者的命令极其相似，格式都为：\ngit config --global https.https://github.com.proxy {protocol}://{ip}:{port} 所以，凭个人喜好使用就好。\n另外，如果代理软件并不在本地运行，那么就将 127.0.0.1 修改为代理软件服务器的 ip（需要有访问权限）。\n修改 .gitconfig 文件 如果不喜欢在命令行中操作，也可以直接修改 C:/Users/${your username}/.gitconfig 文件，在文件末尾添加以下内容：\n通过代理软件 HTTP 的端口 [https \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 [http \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = socks5://127.0.0.1:{port} 取消代理 通过命令行：\ngit config --global --unset https.https://github.com.proxy 也可以修改 C:/Users/${your username}/.gitconfig 文件，删除或注释 [https \u0026quot;https://github.com\u0026quot;] 区域的内容。\n为 SSH 协议设置代理 在 GitHub上，通过第二种方式克隆仓库，走的就是 SSH 协议：\n修改 .ssh/config 文件 找到 ~/.ssh 目录下的 config 文件（如果没有找到这个文件，那么新建即可）。\n通过代理软件 HTTP 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 window 下使用的代理软件为 connect # -H为HTTP协议， -S指Socks 5协议 # {port} 修改为代理软件的端口 ProxyCommand connect -H 127.0.0.1:{port} %h %p # 服务对应端口 Port 443 通过代理软件 Sock5 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 window 下使用的代理软件为 connect # -H为HTTP协议， -S指Socks 5协议 # {port} 修改为代理软件的端口 ProxyCommand connect -S 127.0.0.1:{port} %h %p # 服务对应端口 Port 443 验证 先打开 git bash ，然后执行：\nssh -T git@github.com` 结果类似：\n$ ssh -T git@github.com Hi niluan304! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 类 Unix 系统 为 HTTP 协议设置代理 在 GitHub上，通过第一种方式克隆仓库，这里走的就是 HTTP 协议，修改起来也很简单：\n命令行设置 通过代理软件 HTTP 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy socks5://127.0.0.1:{port} 可以发现，两者的命令极其相似，格式都为：\ngit config --global https.https://github.com.proxy {protocol}://{ip}:{port} 所以，凭个人喜好使用就好。\n另外，如果代理软件并不在本地运行，那么就将 127.0.0.1 修改为代理软件服务器的 ip（需要有访问权限）。\n修改 .gitconfig 文件 如果不喜欢在命令行中操作，也可以直接修改 ~/.gitconfig 文件，在文件末尾添加以下内容：\n通过代理软件 HTTP 的端口 [https \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 [http \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = socks5://127.0.0.1:{port} 取消代理 通过命令行：\ngit config --global --unset https.https://github.com.proxy 也可以修改 ~/.gitconfig 文件，删除或注释 [https \u0026quot;https://github.com\u0026quot;] 区域的内容。\n为 SSH 协议设置代理 在 GitHub上，通过第二种方式克隆仓库，走的就是 SSH 协议：\n修改 .ssh/config 文件 找到 ~/.ssh 目录下的 config 文件（如果没有找到这个文件，那么新建即可）。\n通过代理软件 HTTP 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 Linux 和 Mac 下使用的代理软件为 netcat，简称nc。 # -X 5 指代理协议Socks 5， -X 4 指代理协议Socks 4， -X connect指代理协议Socks HTTP ProxyCommand nc -v -X 127.0.0.1:xxxx %h %p # 服务对应端口 Port 443 通过代理软件 Sock5 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 Linux 和 Mac 下使用的代理软件为 netcat，简称nc。 # -X 5 指代理协议Socks 5， -X 4 指代理协议Socks 4， -X connect指代理协议Socks HTTP ProxyCommand nc -v -X 5 127.0.0.1:xxxx %h %p # 服务对应端口 Port 443 验证 先打开 git bash ，然后执行：\nssh -T git@github.com 结果类似：\n$ ssh -T git@github.com Hi niluan304! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 如果遇到错误，可以删除 .ssh 目录中 known_hosts 文件后重试。\n","date":"2023-03-14T18:08:02+08:00","permalink":"https://niluan304.github.io/p/%E4%B8%BA-git-clone-github-%E8%AE%BE%E7%BD%AE-http-%E5%92%8C-ssh-%E4%BB%A3%E7%90%86/","title":"为 git clone github 设置 HTTP 和 SSH 代理"},{"content":"使用 slices.Sort 和 slices.SortFunc 避免 sort.Slices 的坑\nsort.Slices 介绍 sort.Slices 是go 于1.18 版本新增的排序函数，签名如下：\nfunc Slice(x any, less func(i, j int) bool) 使用起来非常简单：\nfunc main() { type Student struct { Name string Age int } students := []Student{ {Name: \u0026#34;Gopher\u0026#34;, Age: 14}, {Name: \u0026#34;Carol\u0026#34;, Age: 10}, {Name: \u0026#34;Alice\u0026#34;, Age: 10}, {Name: \u0026#34;Bob\u0026#34;, Age: 15}, {Name: \u0026#34;Dave\u0026#34;, Age: 12}, } // sort by Age first, Name second sort.Slice(students, func(i, j int) bool { x, y := students[i], students[j] if x.Age != y.Age { return x.Age \u0026lt; y.Age } return x.Name \u0026lt; y.Name }) for _, student := range students { fmt.Printf(\u0026#34;%d %s\\n\u0026#34;, student.Age, student.Name) } } // Output: // 10 Alice // 10 Carol // 12 Dave // 14 Gopher // 15 Bob 闭包的坑 上面的代码中，甚至进行了多字段排序。但如果我们只需要部分排序，代码又该怎么写呢？\n这样对吗？\nfunc SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { return nums[i] \u0026lt; nums[j] }) } 咋一看没什么问题，跑下测试用例吧：\nfunc main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 SortAfter(got, tt.p) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } // Output: // when p: 1 ,want: [2 1 3 4 5 6 7], but got: [2 3 5 6 7 4 1] // when p: 3 ,want: [2 3 1 4 5 6 7], but got: [2 3 1 5 6 4 7] 为什么 p = 1,3 时不对，p = 2 时又是对的呢？ 因为 sort.Slices 接收到的参数是 nums[p:]，less 闭包里的参数 i, j 是在 nums[p:] 的位置，如果直接比较 nums[i] 和nums[j]，那就忽略了 p 偏移的影响，所以实际要比较的元素其实是 nums[i+p] 和 nums[j+p]，那么修复后的函数：\nfunc SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { // 这里传入的slice不再是完整的nums，而是nums[p:] return nums[i+p] \u0026lt; nums[j+p] }) } 使用 slices.Sort 优化 手动修正偏移量，可以避免部分排序这个坑一时，但日后依旧有可能因为思维惯性而导致再次踩坑。具体实现也很别扭，也不方便修改。\n好在 go 在 1.21 版本新增了了 slices 这个泛型库，里面包含了很多切片的通用操作，其中的 slices.Sort 和 slices.SortFunc 函数就可以避免上面的坑。\n这两个函数的签名：\nfunc Sort[S ~[]E, E cmp.Ordered](x S) func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) 使用方法也很简单，直接传入要排序的部分，如果调用 slices.Sort，还可以省去用手写 less 闭包函数。 最重要的是，按照直觉使用这两个函数就可以避免 sort.Slices 在部分排序时的坑：\nfunc main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 0, want: []int{1, 2, 3, 4, 5, 6, 7}}, {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 slices.Sort(got[tt.p:]) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } 而使用 sort.SortFunc，搭配 go 1.22 新增的泛型函数 cmp.Or，可以更轻松的实现多字段排序，这段代码来自 go1.22 标准库 cmp/cmp_test.go：\nfunc main() { type Order struct { Product string Customer string Price float64 } orders := []Order{ {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 1.00}, {\u0026#34;bar\u0026#34;, \u0026#34;bob\u0026#34;, 3.00}, {\u0026#34;baz\u0026#34;, \u0026#34;carol\u0026#34;, 4.00}, {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 2.00}, {\u0026#34;bar\u0026#34;, \u0026#34;carol\u0026#34;, 1.00}, {\u0026#34;foo\u0026#34;, \u0026#34;bob\u0026#34;, 4.00}, } // Sort by customer first, product second, and last by higher price slices.SortFunc(orders, func(a, b Order) int { return cmp.Or( cmp.Compare(a.Customer, b.Customer), cmp.Compare(a.Product, b.Product), cmp.Compare(b.Price, a.Price), ) }) for _, order := range orders { fmt.Printf(\u0026#34;%s %s %.2f\\n\u0026#34;, order.Product, order.Customer, order.Price) } } // Output: // foo alice 2.00 // foo alice 1.00 // bar bob 3.00 // foo bob 4.00 // bar carol 1.00 // baz carol 4.00 其中 cmp.Or 的源码 非常简单，只是用于找出切片中第一个非零的元素：\n// Or returns the first of its arguments that is not equal to the zero value. // If no argument is non-zero, it returns the zero value. func Or[T comparable](vals ...T) T { var zero T for _, val := range vals { if val != zero { return val } } return zero } 可以看到，这样写 less 函数，比手写多个 if 优雅太多了。\n参考资料 golang sort.Slice踩坑记录 - 简书 ","date":"2023-03-11T00:00:00Z","image":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/Feng_2024-03-12_10-13-25_huca69348bf10406e412f1d3e0ec3bf9be_11506_120x120_fill_box_smart1_3.png","permalink":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/","title":"sort.Slice 不适合部分排序"},{"content":"wsl 常用命令 重启 wsl 尝试重启 wsl，使用命令 wsl --shuntdown 或其他命令，终端被挂起，无反应。\n解决办法：kill LxssManager\n找到 svchost.exe 进程的 pid, 然后在「任务管理器/详细信息」里结束这个进程 echo 寻找 `pid` 的指令： tasklist /svc /fi \u0026#34;imagename eq svchost.exe\u0026#34; | findstr LxssManager PowerShell7 里 kill LxssManager echo 在 `PowerShell7` 里运行（可能需要管理员启动）： Stop-Process -Id $(Get-CimInstance -ClassName Win32_Service -Filter \u0026#34;Name=\u0026#39;LxssManager\u0026#39;\u0026#34;).ProcessId -Force 安装 docker 最简单的办法，大概是安装 Docker Desktop，笔者使用了一段时间，似乎有兼容性问题（可能和笔者同时使用 Hyper-V 安卓模拟器有关系），于是又更换为 Linux 版本的 docker。\n直接运行官方的脚本，即可完成安装：\ncurl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo service docker start 但是笔者的机器安装过 Docker Desktop，运行 service docker start 后显示：\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 经过排查，发现还需要清理 Docker Desktop 相关的配置。安装过 Docker Desktop，所以 docker 的配置文件 /root/.docker/config.json 含有这个配置项：\n{ \u0026#34;credsStore\u0026#34;: \u0026#34;desktop.exe\u0026#34; } docker 会因为配置了 \u0026quot;credsStore\u0026quot; 字段去运行 \u0026quot;desktop.exe\u0026quot;，而这个程序就是 Docker Desktpo，才导致 docker 无法启动。\n解决办法：\n删除 docker 配置文件里的 \u0026quot;credsStore\u0026quot; 字段。 如果里面的配置不重要，也可以直接删除这个文件：rm /root/.docker/config.json。 ","date":"2023-02-10T10:28:36+08:00","permalink":"https://niluan304.github.io/p/wsl-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"Wsl 使用笔记"}]