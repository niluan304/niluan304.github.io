[{"content":"在国内执行 git clone https://github.com/golang/go.git 操作，又慢又不稳定，搜索后发现可以使用代理这个问题。\n准备工作 首先，你需要准备好代理工具，一般的代理工具都有 Sock5 和 HTTP 两种代理方式。\n常见的代理软件使用的端口有：7890, 1080，下文的 {port} 参数都需要修改为对应的端口号。\n笔者会按照 Windows 和 类 Unix 系统介绍为 git 设置代理的方法，由于相似处很多，请按需查看。\nWindows 下 为 HTTP 协议设置代理 在 GitHub上，通过第一种方式克隆仓库，这里走的就是 HTTP 协议，修改起来也很简单：\n命令行设置 通过代理软件 HTTP 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy socks5://127.0.0.1:{port} 可以发现，两者的命令极其相似，格式都为：\ngit config --global https.https://github.com.proxy {protocol}://{ip}:{port} 所以，凭个人喜好使用就好。\n另外，如果代理软件并不在本地运行，那么就将 127.0.0.1 修改为代理软件服务器的 ip（需要有访问权限）。\n修改 .gitconfig 文件 如果不喜欢在命令行中操作，也可以直接修改 C:/Users/${your username}/.gitconfig 文件，在文件末尾添加以下内容：\n通过代理软件 HTTP 的端口 [https \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 [http \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = socks5://127.0.0.1:{port} 取消代理 通过命令行：\ngit config --global --unset https.https://github.com.proxy 也可以修改 C:/Users/${your username}/.gitconfig 文件，删除或注释 [https \u0026quot;https://github.com\u0026quot;] 区域的内容。\n为 SSH 协议设置代理 在 GitHub上，通过第二种方式克隆仓库，走的就是 SSH 协议：\n修改 .ssh/config 文件 找到 ~/.ssh 目录下的 config 文件（如果没有找到这个文件，那么新建即可）。\n通过代理软件 HTTP 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 window 下使用的代理软件为 connect # -H为HTTP协议， -S指Socks 5协议 # {port} 修改为代理软件的端口 ProxyCommand connect -H 127.0.0.1:{port} %h %p # 服务对应端口 Port 443 通过代理软件 Sock5 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 window 下使用的代理软件为 connect # -H为HTTP协议， -S指Socks 5协议 # {port} 修改为代理软件的端口 ProxyCommand connect -S 127.0.0.1:{port} %h %p # 服务对应端口 Port 443 验证 先打开 git bash ，然后执行：\nssh -T git@github.com` 结果类似：\n$ ssh -T git@github.com Hi niluan304! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 类 Unix 系统 为 HTTP 协议设置代理 在 GitHub上，通过第一种方式克隆仓库，这里走的就是 HTTP 协议，修改起来也很简单：\n命令行设置 通过代理软件 HTTP 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 在终端中执行以下命令： # {port} 修改为代理软件的端口 git config --global https.https://github.com.proxy socks5://127.0.0.1:{port} 可以发现，两者的命令极其相似，格式都为：\ngit config --global https.https://github.com.proxy {protocol}://{ip}:{port} 所以，凭个人喜好使用就好。\n另外，如果代理软件并不在本地运行，那么就将 127.0.0.1 修改为代理软件服务器的 ip（需要有访问权限）。\n修改 .gitconfig 文件 如果不喜欢在命令行中操作，也可以直接修改 ~/.gitconfig 文件，在文件末尾添加以下内容：\n通过代理软件 HTTP 的端口 [https \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = https://127.0.0.1:{port} 通过代理软件 Sock5 的端口 [http \u0026#34;https://github.com\u0026#34;] # {port} 修改为代理软件的端口 proxy = socks5://127.0.0.1:{port} 取消代理 通过命令行：\ngit config --global --unset https.https://github.com.proxy 也可以修改 ~/.gitconfig 文件，删除或注释 [https \u0026quot;https://github.com\u0026quot;] 区域的内容。\n为 SSH 协议设置代理 在 GitHub上，通过第二种方式克隆仓库，走的就是 SSH 协议：\n修改 .ssh/config 文件 找到 ~/.ssh 目录下的 config 文件（如果没有找到这个文件，那么新建即可）。\n通过代理软件 HTTP 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 Linux 和 Mac 下使用的代理软件为 netcat，简称nc。 # -X 5 指代理协议Socks 5， -X 4 指代理协议Socks 4， -X connect指代理协议Socks HTTP ProxyCommand nc -v -X 127.0.0.1:xxxx %h %p # 服务对应端口 Port 443 通过代理软件 Sock5 的端口 config 文件末尾添加以下内容： Host github.com Hostname ssh.github.com # git 在 Linux 和 Mac 下使用的代理软件为 netcat，简称nc。 # -X 5 指代理协议Socks 5， -X 4 指代理协议Socks 4， -X connect指代理协议Socks HTTP ProxyCommand nc -v -X 5 127.0.0.1:xxxx %h %p # 服务对应端口 Port 443 验证 先打开 git bash ，然后执行：\nssh -T git@github.com 结果类似：\n$ ssh -T git@github.com Hi niluan304! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 如果遇到错误，可以删除 .ssh 目录中 known_hosts 文件后重试。\n","date":"2024-03-14T18:08:02+08:00","permalink":"https://niluan304.github.io/p/%E4%B8%BA-git-clone-github-%E8%AE%BE%E7%BD%AE-http-%E5%92%8C-ssh-%E4%BB%A3%E7%90%86/","title":"为 git clone github 设置 HTTP 和 SSH 代理"},{"content":"使用 slices.Sort 和 slices.SortFunc 避免 sort.Slices 的坑\nsort.Slices 介绍 sort.Slices 是go 于1.18 版本新增的排序函数，签名如下：\nfunc Slice(x any, less func(i, j int) bool) 使用起来非常简单：\nfunc main() { type Student struct { Name string Age int } students := []Student{ {Name: \u0026#34;Gopher\u0026#34;, Age: 14}, {Name: \u0026#34;Carol\u0026#34;, Age: 10}, {Name: \u0026#34;Alice\u0026#34;, Age: 10}, {Name: \u0026#34;Bob\u0026#34;, Age: 15}, {Name: \u0026#34;Dave\u0026#34;, Age: 12}, } // sort by Age first, Name second sort.Slice(students, func(i, j int) bool { x, y := students[i], students[j] if x.Age != y.Age { return x.Age \u0026lt; y.Age } return x.Name \u0026lt; y.Name }) for _, student := range students { fmt.Printf(\u0026#34;%d %s\\n\u0026#34;, student.Age, student.Name) } } // Output: // 10 Alice // 10 Carol // 12 Dave // 14 Gopher // 15 Bob 闭包的坑 上面的代码中，甚至进行了多字段排序。但如果我们只需要部分排序，代码又该怎么写呢？\n这样对吗？\nfunc SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { return nums[i] \u0026lt; nums[j] }) } 咋一看没什么问题，跑下测试用例吧：\nfunc main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 SortAfter(got, tt.p) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } // Output: // when p: 1 ,want: [2 1 3 4 5 6 7], but got: [2 3 5 6 7 4 1] // when p: 3 ,want: [2 3 1 4 5 6 7], but got: [2 3 1 5 6 4 7] 为什么 p = 1,3 时不对，p = 2 时又是对的呢？ 因为 sort.Slices 接收到的参数是 nums[p:]，less 闭包里的参数 i, j 是在 nums[p:] 的位置，如果直接比较 nums[i] 和nums[j]，那就忽略了 p 偏移的影响，所以实际要比较的元素其实是 nums[i+p] 和 nums[j+p]，那么修复后的函数：\nfunc SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { // 这里传入的slice不再是完整的nums，而是nums[p:] return nums[i+p] \u0026lt; nums[j+p] }) } 使用 slices.Sort 优化 手动修正偏移量，可以避免部分排序这个坑一时，但日后依旧有可能因为思维惯性而导致再次踩坑。具体实现也很别扭，也不方便修改。\n好在 go 在 1.21 版本新增了了 slices 这个泛型库，里面包含了很多切片的通用操作，其中的 slices.Sort 和 slices.SortFunc 函数就可以避免上面的坑。\n这两个函数的签名：\nfunc Sort[S ~[]E, E cmp.Ordered](x S) func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) 使用方法也很简单，直接传入要排序的部分，如果调用 slices.Sort，还可以省去用手写 less 闭包函数。 最重要的是，按照直觉使用这两个函数就可以避免 sort.Slices 在部分排序时的坑：\nfunc main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 0, want: []int{1, 2, 3, 4, 5, 6, 7}}, {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 slices.Sort(got[tt.p:]) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } 而使用 sort.SortFunc，搭配 go 1.22 新增的泛型函数 cmp.Or，可以更轻松的实现多字段排序，这段代码来自 go1.22 标准库 cmp/cmp_test.go：\nfunc main() { type Order struct { Product string Customer string Price float64 } orders := []Order{ {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 1.00}, {\u0026#34;bar\u0026#34;, \u0026#34;bob\u0026#34;, 3.00}, {\u0026#34;baz\u0026#34;, \u0026#34;carol\u0026#34;, 4.00}, {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 2.00}, {\u0026#34;bar\u0026#34;, \u0026#34;carol\u0026#34;, 1.00}, {\u0026#34;foo\u0026#34;, \u0026#34;bob\u0026#34;, 4.00}, } // Sort by customer first, product second, and last by higher price slices.SortFunc(orders, func(a, b Order) int { return cmp.Or( cmp.Compare(a.Customer, b.Customer), cmp.Compare(a.Product, b.Product), cmp.Compare(b.Price, a.Price), ) }) for _, order := range orders { fmt.Printf(\u0026#34;%s %s %.2f\\n\u0026#34;, order.Product, order.Customer, order.Price) } } // Output: // foo alice 2.00 // foo alice 1.00 // bar bob 3.00 // foo bob 4.00 // bar carol 1.00 // baz carol 4.00 其中 cmp.Or 的源码 非常简单，只是用于找出切片中第一个非零的元素：\n// Or returns the first of its arguments that is not equal to the zero value. // If no argument is non-zero, it returns the zero value. func Or[T comparable](vals ...T) T { var zero T for _, val := range vals { if val != zero { return val } } return zero } 可以看到，这样写 less 函数，比手写多个 if 优雅太多了。\n参考资料 golang sort.Slice踩坑记录 - 简书 ","date":"2024-03-11T00:00:00Z","image":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/Feng_2024-03-12_10-13-25_huca69348bf10406e412f1d3e0ec3bf9be_11506_120x120_fill_box_smart1_3.png","permalink":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/","title":"sort.Slice 不适合部分排序"}]