[{"content":"使用 slices.Sort 和 slices.SortFunc 避免 sort.Slices 的坑\nsort.Slices 介绍 sort.Slices 是go 于1.18 版本新增的排序函数，签名如下：\n1 func Slice(x any, less func(i, j int) bool) 使用起来非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func main() { type Student struct { Name string Age int } students := []Student{ {Name: \u0026#34;Gopher\u0026#34;, Age: 14}, {Name: \u0026#34;Carol\u0026#34;, Age: 10}, {Name: \u0026#34;Alice\u0026#34;, Age: 10}, {Name: \u0026#34;Bob\u0026#34;, Age: 15}, {Name: \u0026#34;Dave\u0026#34;, Age: 12}, } // sort by Age first, Name second sort.Slice(students, func(i, j int) bool { x, y := students[i], students[j] if x.Age != y.Age { return x.Age \u0026lt; y.Age } return x.Name \u0026lt; y.Name }) for _, student := range students { fmt.Printf(\u0026#34;%d %s\\n\u0026#34;, student.Age, student.Name) } } // Output: // 10 Alice // 10 Carol // 12 Dave // 14 Gopher // 15 Bob 闭包的坑 上面的代码中，甚至进行了多字段排序。但如果我们只需要部分排序，代码又该怎么写呢？\n这样对吗？\n1 2 3 4 5 func SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { return nums[i] \u0026lt; nums[j] }) } 咋一看没什么问题，跑下测试用例吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 SortAfter(got, tt.p) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } // Output: // when p: 1 ,want: [2 1 3 4 5 6 7], but got: [2 3 5 6 7 4 1] // when p: 3 ,want: [2 3 1 4 5 6 7], but got: [2 3 1 5 6 4 7] 为什么 p = 1,3 时不对，p = 2 时又是对的呢？ 因为 sort.Slices 接收到的参数是 nums[p:]，less 闭包里的参数 i, j 是在 nums[p:] 的位置，如果直接比较 nums[i] 和nums[j]，那就忽略了 p 偏移的影响，所以实际要比较的元素其实是 nums[i+p] 和 nums[j+p]，那么修复后的函数：\n1 2 3 4 5 func SortAfter(nums []int, p int) { // 从p开始排序 sort.Slice(nums[p:], func(i, j int) bool { // 这里传入的slice不再是完整的nums，而是nums[p:] return nums[i+p] \u0026lt; nums[j+p] }) } 使用 slices.Sort 优化 手动修正偏移量，可以避免部分排序这个坑一时，但日后依旧有可能因为思维惯性而导致再次踩坑。具体实现也很别扭，也不方便修改。\n好在 go 在 1.21 版本新增了了 slices 这个泛型库，里面包含了很多切片的通用操作，其中的 slices.Sort 和 slices.SortFunc 函数就可以避免上面的坑。\n这两个函数的签名：\n1 2 func Sort[S ~[]E, E cmp.Ordered](x S) func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) 使用方法也很简单，直接传入要排序的部分，如果调用 slices.Sort，还可以省去用手写 less 闭包函数。 最重要的是，按照直觉使用这两个函数就可以避免 sort.Slices 在部分排序时的坑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { nums := []int{2, 3, 1, 5, 4, 6, 7} tests := []struct { p int want []int }{ {p: 0, want: []int{1, 2, 3, 4, 5, 6, 7}}, {p: 1, want: []int{2, 1, 3, 4, 5, 6, 7}}, {p: 2, want: []int{2, 3, 1, 4, 5, 6, 7}}, {p: 3, want: []int{2, 3, 1, 4, 5, 6, 7}}, } for _, tt := range tests { got := slices.Clone(nums) // 拷贝原始数据，用于测试 slices.Sort(got[tt.p:]) if !reflect.DeepEqual(got, tt.want) { fmt.Printf(\u0026#34;when p: %v ,want: %v, but got: %v\\n\u0026#34;, tt.p, tt.want, got) } } } 而使用 sort.SortFunc，搭配 go 1.22 新增的泛型函数 cmp.Or，可以更轻松的实现多字段排序，这段代码来自 go1.22 标准库 cmp/cmp_test.go：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func main() { type Order struct { Product string Customer string Price float64 } orders := []Order{ {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 1.00}, {\u0026#34;bar\u0026#34;, \u0026#34;bob\u0026#34;, 3.00}, {\u0026#34;baz\u0026#34;, \u0026#34;carol\u0026#34;, 4.00}, {\u0026#34;foo\u0026#34;, \u0026#34;alice\u0026#34;, 2.00}, {\u0026#34;bar\u0026#34;, \u0026#34;carol\u0026#34;, 1.00}, {\u0026#34;foo\u0026#34;, \u0026#34;bob\u0026#34;, 4.00}, } // Sort by customer first, product second, and last by higher price slices.SortFunc(orders, func(a, b Order) int { return cmp.Or( cmp.Compare(a.Customer, b.Customer), cmp.Compare(a.Product, b.Product), cmp.Compare(b.Price, a.Price), ) }) for _, order := range orders { fmt.Printf(\u0026#34;%s %s %.2f\\n\u0026#34;, order.Product, order.Customer, order.Price) } } // Output: // foo alice 2.00 // foo alice 1.00 // bar bob 3.00 // foo bob 4.00 // bar carol 1.00 // baz carol 4.00 其中 cmp.Or 的源码 非常简单，只是用于找出切片中第一个非零的元素：\n1 2 3 4 5 6 7 8 9 10 11 // Or returns the first of its arguments that is not equal to the zero value. // If no argument is non-zero, it returns the zero value. func Or[T comparable](vals ...T) T { var zero T for _, val := range vals { if val != zero { return val } } return zero } 可以看到，这样写 less 函数，比手写多个 if 优雅太多了。\n参考资料 golang sort.Slice踩坑记录 - 简书 ","date":"2024-03-11T00:00:00Z","image":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/Feng_2024-03-12_10-13-25_huca69348bf10406e412f1d3e0ec3bf9be_11506_120x120_fill_box_smart1_3.png","permalink":"https://niluan304.github.io/p/sort.slice-%E4%B8%8D%E9%80%82%E5%90%88%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/","title":"sort.Slice 不适合部分排序"},{"content":"$$ x+y=z $$\n$132$ 模式的进阶，求 $1324$ 模式 的个数：枚举 4 ，求 4 左边 132 模式的数量\n前言 四元上升组定义：一个组 $(i, j, k, l)$ 满足以下条件：\n$0 \u0026lt;= i \u0026lt; j \u0026lt; k \u0026lt; l \u0026lt; n $ 且 $nums[i] \u0026lt; nums[k] \u0026lt; nums[j] \u0026lt; nums[l] $。 在数组中是这样的：\n这里称之为 $1324$ 模式，如果有疑惑，请先AC：456. 132 模式\nAC后，可以先思考下：返回长度 $n-2$ 的数组，记录每个 $j$ 下有多少个 $132$ 模式。\n$ nums[i] \u0026lt; nums[k] \u0026lt; nums[j] \\quad \\quad i\u0026lt;j\u0026lt;k $\n解法的时间复杂度应当不超过 $\\mathcal{O}(n^2)$\n比如 示例3：$nums = [-1,3,2,0]$\n$j=1$ 下有 $2$ 个 $132$ 模式的的子序列：$[-1, 3, 2]$、$[-1, 3, 0]$\n$j=2$ 下有 $1$ 个 $132$ 模式的的子序列：$[-1, 2, 0]$\n那么答案为：$ans = [2,1]$\n注意：\n本篇内容是尝试去拆分 佬@DestinyGod 题解最简洁代码，从而得到的个人理解。\n思路 题目要求统计数组中有多少个 $1324$ 模式。\n题目数据范围：$4 \u0026lt;= nums.length \u0026lt;= 4000$，意味着代码的时间复杂度应为 $\\mathcal{O}(n^2)$，部分语言 $\\mathcal{O}(n^2 \\log n)$ 也可以AC。\n枚举 j 和 l 时间复杂度度 $\\mathcal{O}(n^2)$ 可以过，可以枚举最大的 $3$ 和 $4$ ，设索引分别为 $j$ 和 $l$。\n如果知道在区间 $[0, l]$ 内，以 $j$ 为 $3$ 的 $132$ 模式的数量，记为 $count[l][j]$，并在双重循环中累加起来，那就是答案了。\n伪代码：\n1 2 3 4 5 6 7 8 9 10 // 从小到大枚举 l 统计答案 // 如果 nums[j] \u0026lt; nums[l]，那么有 `j为3, l为4` 的 `1324模式` // 答案应当加上以 `j为3` 的 `132模式` 的数量 for l := 0; l \u0026lt; n; l++ { for j := 0; j \u0026lt; l; j++ { if nums[j] \u0026lt; nums[l] { // 符合 1324 模式 ans += count[l][j] // count[l][j] 表示 在区间 [0, l] 内，以 `j为3` 的 `132模式` 的数量 } } } 可以看出，这部分代码的时间复杂度是 $\\mathcal{O}(n^2)$，如果能在时间复杂度 $\\mathcal{O}(n^2)$ 以内预处理好 $count[l][j]$，那么就可以完成此题。\n预处理 count[l][j] 需要注意在区间 $[0, l]$ 内，以 $j$ 为 $3$ 的 $132$ 模式的所有数量，等于 所有能满足\n$ nums[i] \u0026lt; nums[k] \u0026lt; nums[j] \\quad \\quad \\quad i \\in [0, j-1],\\ k \\in [j+1, l-1] $\n$(i, k)$ 的对数\n计算 $count[l][j]$，可以借助动态规划的思想。\n在区间 $[0, l]$ 内，以 $j$ 为 $3$ 的 $132$ 模式的所有数量 等于 在区间 $[0, l-1]$ 内的数量加上以 $j$ 为 $3$，以 $l$ 为 $2$ 的 $132$ 的数量，记为 $x$，即：\n$ count[l][j] = count[l-1][j] + x $\n而 $x$ 就是 在 $[0,j-1]$ 区间内，小于 $nums[l]$ 的数量，那如何计算 $x$ 呢？暴力枚举：\n1 2 3 4 5 6 x := 0 for j := 0; j \u0026lt; l; j++ { if nums[j] \u0026lt; nums[l] { x++ } } 在加上枚举 $l$ 的实现，就得到 预处理 $count[l][j]$的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // count[l][j] 表示 在 [0, l] 这段区间内，以 `j为3` 的 `132模式` 数量 var count = make([][]int, n) for l := 0; l \u0026lt; n; l++ { count[l] = make([]int, l+1) x := 0 // x 记录 [0, j] 这段区间，有多少个数小于 nums[l] // 动态规划的思想 for j := 0; j \u0026lt; l; j++ { // 在 [0, l] 区间，以 `j为3` 的 `132模式` 数量等于在 [0, l-1] 区间内的数量 + 以 `j为3`，以 `l为2` 的 `132模式` 的数量 count[l][j] = count[l-1][j] // 如果 nums[j] \u0026gt; nums[l]，说明 nums[l] 可以作为新的 2，新增的数量：在 [0, j] 区间中小于 nums[l] 的个数， // 也就是以 `j为3, l为2` 的 `132模式` 中，x 就为 1 的数量。 if nums[j] \u0026gt; nums[l] { count[l][j] += x } else // 如果 nums[j] \u0026lt; nums[l]，说明不满足 `132模式`。但是小于 nums[l] 的数量 +1 if nums[j] \u0026lt; nums[l] { x++ } } } 代码 组合代码 组合 枚举 $j$ 和 $l$ 和 预处理 $count[l][j]$ 的代码即可解决本题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func countQuadruplets(nums []int) int64 { // 1324 模式 // i \u0026lt; j \u0026lt; k \u0026lt; l // nums[i] \u0026lt; nums[k] \u0026lt; nums[j] \u0026lt; nums[l] var n, ans = len(nums), 0 // count[l][j] 表示 在 [0, l] 这段区间内，以 `j为3` 的 `132模式` 数量 var count = make([][]int, n) for l := 0; l \u0026lt; n; l++ { count[l] = make([]int, l+1) x := 0 // x 记录 [0, j] 这段区间，有多少个数小于 nums[l] // 动态规划的思想 for j := 0; j \u0026lt; l; j++ { // 在 [0, l] 区间，以 `j为3` 的 `132模式` 数量等于在 [0, l-1] 区间内的数量加上以 `j为3`，以 `l为2` 的 `132模式` 的数量 count[l][j] = count[l-1][j] // 如果 nums[j] \u0026gt; nums[l]，说明 nums[l] 可以作为新的 2，新增的数量：在 [0, j] 区间中小于 nums[l] 的个数， // 也就是以 `j为3, l为2` 的 `132模式` 中，x 就为 1 的数量。 if nums[j] \u0026gt; nums[l] { count[l][j] += x } else // 如果 nums[j] \u0026lt; nums[l]，说明不满足 `132模式`。但是小于 nums[l] 的数量 +1 if nums[j] \u0026lt; nums[l] { x++ } } } // 从小到大枚举 l 统计答案 // 如果 nums[j] \u0026lt; nums[l]，那么有 `j为3, l为4` 的 `1324模式` // 答案应当加上以 `j为3` 的 `132模式` 的数量 for l := 0; l \u0026lt; n; l++ { for j := 0; j \u0026lt; l; j++ { if nums[j] \u0026lt; nums[l] { // 符合 1324 模式 ans += count[l][j] // count[l][j] 表示 在区间 [0, l] 内，以 `j为3` 的 `132模式` 的数量 } } } return int64(ans) } 空间优化 可以发现， 枚举 $j$ 和 $l$ 和 预处理 $count[l][j]$ 的遍历的顺序都是一样的：外层遍历 $l$, 内层遍历 $j$\n那么可以一边统计答案，一边预处理$count[l][j]$，同时也可以把 $count[l][j]$ 压缩到一维数组。\n这就是 题解最简洁代码 的解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func countQuadruplets(nums []int) int64 { // 1324 模式 // i \u0026lt; j \u0026lt; k \u0026lt; l // nums[i] \u0026lt; nums[k] \u0026lt; nums[j] \u0026lt; nums[l] var n, ans = len(nums), 0 // count[l][j] 表示 在 [0, l] 这段区间内，以 `j为3` 的 `132模式` 数量 // 一边统计答案，一边预处理 count[l][j]，并将 count[l][j] 为 一维数组 var count = make([]int, n) for l := 0; l \u0026lt; n; l++ { x := 0 // x 记录 [0, j] 这段区间，有多少个数小于 nums[l] for j := 0; j \u0026lt; l; j++ { // 动态规划的思想 // 在 [0, l] 区间，以 `j为3` 的 `132模式` 数量等于在 [0, l-1] 区间内的数量 + 以 `j为3`，以 `k为2` 的 `132模式` 的数量 // 如果 nums[j] \u0026gt; nums[l]，说明 nums[l] 可以作为新的 2，而新增的数量为：在 [0, j] 区间中小于 nums[l] 的个数， // 也就是以 `j为3, k为2` 的 `132模式` 中，1 的数量。 if nums[j] \u0026gt; nums[l] { count[j] += x } else // 如果 nums[j] \u0026lt; nums[l]，说明有 `j为3, l为4` 的 `1324` 模式 // 并且 在 [0,j] 区间内 小于 nums[l] 的数量 +1 if nums[j] \u0026lt; nums[l] { ans += count[j] x++ } } } return int64(ans) } ","date":"2024-01-12T00:00:00Z","permalink":"https://niluan304.github.io/p/lc2522.-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/","title":"LC2522. 统计上升四元组"},{"content":"\n读题 根据「这组英雄的力量」的定义，得知元素顺序不影响答案，那么可以先排序，然后固定最大值。\n暴力解法：全排列小于当前最大值的数，再遍历最小值，但是这种做法时间复杂度过高，没办法优化。\n优化暴力解法，也是一种解题方法。\n读题时有两点必须要注意到：\n数据范围： $1 \\leq nums.length \\leq 10^5$，表明本题时间复杂度至多为 $\\mathcal{O}(n\\log n)$; 由于答案可能非常大，请你将结果对 $10^9 + 7$ 取余。 根据我以往的做题经验，猜测本题的解法是动态规划。\n观察与猜测 没什么思路的时，我喜欢在草稿纸上写例子，比如有 $nums = [1,2,3,4,5]$，顺序从小到大。\n以下思考过程是有问题的，因为按子序列个数的划分方式并不方便找到规律。\n设当前最大值为 $a_n$，$[a_1,a_2,\u0026hellip;,a_n]$ 的全排列后的最小值之和为 $S_n$，那么答案为：$\\sum{a_n^2 * S_n}$\n$a_1 = 1, S_1 = [1]$\n$a_2=2, S_2 = [ 2 + (1)]$\n解释：只有 $1$ 个数时：$\\sum\\min{[2]} = 2$，$2$ 个数时：$\\sum\\min{[2,1]} = 1$ $a_3 = 3, S_3 = [3 + (2+1) + (1)]$\n解释：只有 $1$ 个数时：$\\sum\\min{[3]} = 3$，$2$ 个数时：$\\sum\\min{[3,2]} + \\sum\\min{[3,1]} = 2 + 1$，$3$ 个数：$\\sum\\min{[3,2,1]} = 1$ $a_4 = 4, S_4 = [4 + (3+2+1) + (2+1+1) + (1)]$\n$a_5 = 5, S_5 = [5 + (4+3+2+1) + \u0026hellip;]$\n再观察 为了找到规律，我尝试 在 $S_n$ 内逐个固定最大值，再分组 ：\n$a_1 = 1, S_1 = 1$\n$a_2=2, S_2 = 2 + (1)$\n$a_3 = 3, S_3 = 3 + (2+1) + (1)$\n$a_4 = 4, S_4 = 4 + [3+(2+1)+1] + [2+(1)] + (1)$\n$a_5 = 5, S_5 = 5 + {4 + [3+(2+1)+1] + [2+(1)] + (1)} + \u0026hellip;$\n我发现式子有以下特点：\n$a_1 = 1, S_1 = a_1$\n$a_2=2, S_2 = a_2 + S_1$\n$a_3 = 3, S_3 = a_3 + S_2 + S_1$\n$a_4 = 4, S_4 = a_4 + S_3 + S_2 + S_1$\n$a_5 = 5, S_5 = a_5 + S_4 + S_3 + S_2 + S_1$\n根据这样的规划，容易猜测出：$S_n = a_n + \\sum{S_{i-1}}$\n根据错位相减法或换元法，可以求得：$S_n = a_n - a_{n-1} + 2*S_{n-1}$\n代码实现 下面就是编码验证环节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func sumOfPower(nums []int) int { const mod = 1_000_000_007 nums = append(nums, 0) // 哨兵，防止nums[i-1]时数组越界 sort.Ints(nums) var n = len(nums) var dp, power = make([]int, n+1), 0 for i := 1; i \u0026lt; n; i++ { num := nums[i] dp[i] = (num - nums[i-1] + 2*dp[i-1]%mod) % mod power = (power + (num*num%mod)*dp[i]) % mod } return power } 复杂度分析 时间复杂度：$\\mathcal{O}(n\\log n)$，其中 $n$ 为 $\\textit{nums}$ 的长度。 空间复杂度：$\\mathcal{O}(n)$。 感想 虽然过程崎岖，但胜在收获不错，动态规划的题目，如果没有思路，在草稿纸上列出具体的例子，或许能帮助你发现数据的规律，并找到解题方法。\n非常感谢你的阅读，衷心祝愿你不会踩到取模陷阱。\n","date":"2024-01-06T00:00:00Z","permalink":"https://niluan304.github.io/p/lc2681.-%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/","title":"LC2681. 英雄的力量"},{"content":"\n将简单难度的题目拓展到中等难度\n动态规划入门：递归 本题 70. 爬楼梯 是非常经典的动态规划入门题，动态规划的核心是找到状态转移方程：当前状态与之前状态的关系。想要找到方程，通常需要我们用自顶向下的方式去思考问题，将一个大问题转化为解决子问题，实现的手段通常为递归。\n读题：\n每次可以爬 $1$ 或 $2$ 阶； 一共要爬 $n$ 阶； 问爬到 $n$ 阶有多少种方法？ 假设当前处于第 $n$ 阶，问：上一步处于哪个阶梯？\n答：处于 $n-1$ 或 $n-2$ 阶。因为每次只能爬 $1$ 阶或 $2$ 阶，那么上一步选择爬 $1$ 阶，就会处于 $n-1$ 阶，选择爬 $2$ 阶，就会处于 $n-2$ 阶。\n解题思路：\n记 $f(n)$ 为爬到 $n$ 阶的方法数，如果知道了 $f(n-1)$ 和 $f(n-2)$ ，两者相加就能得到 $f(n)$ ，即 $f(n) = f(n-1) + f(n-2)$ 。\n那又如何求 $f(n-1)$ 和 $f(n-2)$ 呢？令 $n = n-1$ ，就有 $f(n-1) = f(n-2) + f(n-3)$ ，可以发现，解决的手段就是递归。\n用到了递归，就需要确定递归边界。式子中最小为 $n-2$ ，那么有 $n-2 \u0026gt;= 0$ ，所以 $n_{min}=2$ ，即最后一次递归为 $f(2) = f(1) + f(0)$ 。 示例一还很贴心的解释了如何确定初始值 $f(2) = 1 + 1 = 2$ ，因此 $f(0) = 1; f(1) = 1$ 。\n如果你足够熟悉，会发现这个公式就是斐波那契数的通项公式： 509. 斐波那契数 。不同点仅有： 爬楼梯的初始值是 $f(0) = 1; f(1) = 1$ ; 斐波那契数的是 $f(0) = 0; f(1) = 1$ 。\n因此只需要修改下初始值就能解答此题：\n1 2 3 4 5 6 7 8 9 10 func climbstairs(n int) int { var fib func (n int) int fib = func (n int) int { if n == 0 || n == 1{ return 1 } return fib(n - 2) + fib(n - 1) } return fib(n) } 不过对于题目的数据范围： $1\u0026lt;=n\u0026lt;=45$ ，不做优化是会超时的，因为\n时间复杂度： $O(2^n)$ ，每次递归都需要再计算 $n-1$ 次 空间复杂度： $O(n)$ 递归优化：使用缓存 指数级别的时间复杂度，显然是不能满足题目要求的，那么该如何优化呢？\n举个例子，先画出 $f(5)$ 的递归的过程，这是一颗二叉树，便于观察它的规律： 查看这颗二叉树，可以看到 $f(5) = f(4) + f(3)$ ， $f(4) = f(3) + f(2)$ ，这两个地方都会去计算 $f(3)$ ，而这两次计算的结果都是一样的，那么可以在第一次计算的时候，把计算结果保存到 $cache$ 数组或哈希表中。下次计算时，可以直接返回 $cache$ 的结果。优化后的搜索树就变成这样： 优化后的搜索树只有 $O(n)$ 个节点，因此时间复杂度也优化到了 $O(n)$ 。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func climbStairs(n int) int { var cache = make([]int, n+1) var fib func (n int) int fib = func (n int) int { if n == 0 || n == 1{ return 1 } if cache[n] \u0026gt; 0{ return cache[n] } res := fib(n - 2) + fib(n - 1) cache[n] = res return res } return fib(n) } 将特例化的题目一般化 对于这道经典题目，如果只是止步于此，那就太可惜了。完全可以稍微修改题目，用于如何归纳出递推公式。\n比如，原版是：\n每次你可以爬 $1$ 或 $2$ 个台阶\n那如果修改成：\n每次你可以爬 $k1$ 或 $k2$ 个台阶\n就得到了：\n爬楼梯2 假设你正在爬楼梯。需要 $n$ 阶你才能到达楼顶。\n给你两个正整数 $k1$ 和 $k2$ ，每次你可以爬 $k1$ 或 $k2$ 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n1 func climbStairs2(n int, k1 int, k2 int) int 又或者再增加可以爬 $3$ 阶的选择， 这样就得到了：\n爬楼梯3\n假设你正在爬楼梯。需要 $n$ 阶你才能到达楼顶。\n每次你可以爬 $1$ 或 $2$ 或 $3$ 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n1 func climbStairs3(n int) int 还可以把爬楼梯2和爬楼梯3的修改组合起来，这样就得到了：\n爬楼梯4\n假设你正在爬楼梯。需要 $n$ 阶你才能到达楼顶。\n给你一个正整数数组 $nums$ ， 每次你可以爬 $nums[i]$ 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n1 func climbStairs4(n int, nums []int) int 完成了 climbStairs4 后，很容易发现：\nclimbStairs2 是 climbStairs4 在 $len(nums) = 2$ 条件下的特例； climbStairs3 是 climbStairs4 在 $nums = [1,2,3]$ 条件下的特例。 至此，我们就把一道简单难度的题目拓展为一道中等难度的题目了。另外，这也可以称得上多题一解。\n相关题目练习 377. 组合总和 Ⅳ 2466. 统计构造好字符串的方案数 62. 不同路径 63. 不同路径 II 96. 不同的二叉搜索树 刚开始上手动态规划题目时，建议尽量先使用记忆化搜索解题，再翻译为递推，这也是一题多解的体现。\n递归搜索+缓存=记忆化搜索的内容，拷贝自灵神的视频讲解，视频里还着重讲解了如何将记忆化搜索翻译为递推，推荐观看：动态规划入门：从记忆化搜索到递推【基础算法精讲 17】\n","date":"2023-09-21T00:00:00Z","permalink":"https://niluan304.github.io/p/lc70.-%E4%BB%8E%E7%88%AC%E6%A5%BC%E6%A2%AF%E4%B8%8A%E6%89%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"LC70. 从爬楼梯上手动态规划"}]