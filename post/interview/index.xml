<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>interview on 雾封的笔</title>
        <link>http://localhost:1313/post/interview/</link>
        <description>Recent content in interview on 雾封的笔</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>雾封</copyright>
        <lastBuildDate>Wed, 01 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/post/interview/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Interview Redis</title>
        <link>http://localhost:1313/p/interview-redis/</link>
        <pubDate>Mon, 18 Mar 2024 15:27:20 +0800</pubDate>
        
        <guid>http://localhost:1313/p/interview-redis/</guid>
        <description>&lt;h2 id=&#34;redis-的基本数据类型&#34;&gt;Redis 的基本数据类型&lt;/h2&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;incr&lt;/code&gt; 和 &lt;code&gt;incyby&lt;/code&gt; 命令，可用于实现计数器&lt;/li&gt;
&lt;li&gt;共享 &lt;code&gt;session&lt;/code&gt;，多端登录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;哈希表&#34;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;存储用户信息&lt;/p&gt;
&lt;h3 id=&#34;列表双端链表&#34;&gt;列表（双端链表）&lt;/h3&gt;
&lt;p&gt;应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lpush+lpop=Stack(栈)&lt;/li&gt;
&lt;li&gt;lpush+rpop=Queue（队列）&lt;/li&gt;
&lt;li&gt;lpush+ltrim=Capped Collection（有限集合）&lt;/li&gt;
&lt;li&gt;lpush+brpop=Message Queue（消息队列），&lt;code&gt;brpop&lt;/code&gt; 是带阻塞机制的 &lt;code&gt;rpop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列表实现的消息队列，支持了持久化，但是不支持多播，分组消费等&lt;/p&gt;
&lt;h3 id=&#34;集合-set&#34;&gt;集合 set&lt;/h3&gt;
&lt;p&gt;应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。&lt;/li&gt;
&lt;li&gt;点赞，或点踩，收藏等，可以放到set中实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序集合-sorted-set--zset&#34;&gt;有序集合 sorted set / zset&lt;/h3&gt;
&lt;p&gt;应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么-redis-这么快&#34;&gt;为什么 Redis 这么快&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于内存的数据存储
内存访问速度比硬盘快太多了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单线程模式
使用单线程模式，避免了线程切换的开销
被吐槽了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IO 多路复用
什么是 IO 多路复用？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-持久化方式&#34;&gt;Redis 持久化方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB Redis DataBase
全量备份，对 Redis 进行快照，得到二进制数据后再压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF Append On File
连续的增量备份，存储每次的写命令，有点类似于 &lt;code&gt;MySQL&lt;/code&gt; 的 &lt;code&gt;binlog&lt;/code&gt;，都是先用日志记录开始修改数据，然后再写入硬盘，最后记录完成数据的修改。
优化：重写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存问题&#34;&gt;缓存问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;缓存穿透&lt;/li&gt;
&lt;li&gt;缓存击穿&lt;/li&gt;
&lt;li&gt;缓存雪崩&lt;/li&gt;
&lt;li&gt;缓存污染（或者满了）&lt;/li&gt;
&lt;li&gt;缓存和数据库一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h3&gt;
&lt;p&gt;缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。&lt;/p&gt;
&lt;h4 id=&#34;解决手段&#34;&gt;解决手段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据校验，防御性编程&lt;/li&gt;
&lt;li&gt;设置空值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h3&gt;
&lt;p&gt;缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。&lt;/p&gt;
&lt;h4 id=&#34;解决手段-1&#34;&gt;解决手段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;singleflight 合并请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h3&gt;
&lt;p&gt;缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。&lt;/p&gt;
&lt;h4 id=&#34;解决手段-2&#34;&gt;解决手段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。&lt;/li&gt;
&lt;li&gt;如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。&lt;/li&gt;
&lt;li&gt;设置热点数据永远不过期。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
