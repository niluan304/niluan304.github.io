<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Interview Mysql on 雾封的笔</title>
        <link>http://localhost:1313/post/interview/mysql/</link>
        <description>Recent content in Interview Mysql on 雾封的笔</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>雾封</copyright>
        <lastBuildDate>Mon, 18 Mar 2024 15:27:20 +0800</lastBuildDate><atom:link href="http://localhost:1313/post/interview/mysql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title></title>
        <link>http://localhost:1313/p/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/</guid>
        <description>&lt;h2 id=&#34;并发与锁&#34;&gt;并发与锁&lt;/h2&gt;
&lt;h3 id=&#34;mysql-中有哪几种锁&#34;&gt;MySQL 中有哪几种锁&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/image-8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;粒度划分&#34;&gt;粒度划分&lt;/h4&gt;
&lt;p&gt;如果按锁粒度划分，有以下 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。&lt;/li&gt;
&lt;li&gt;行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。&lt;/li&gt;
&lt;li&gt;页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;兼容性划分&#34;&gt;兼容性划分&lt;/h4&gt;
&lt;p&gt;如果按照兼容性，有两种，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。&lt;/li&gt;
&lt;li&gt;排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;机制划分&#34;&gt;机制划分&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。&lt;/p&gt;
&lt;p&gt;数据库中的行锁，表锁，读锁，写锁均为悲观锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乐观锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;乐观锁认为数据的变动不会太频繁。&lt;/p&gt;
&lt;p&gt;乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。&lt;/p&gt;
&lt;p&gt;事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本 v1 与数据中最新的版本 v2 相对比，如果 v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时 version 会加 1，以此来表明数据已被变动。&lt;/p&gt;
&lt;p&gt;如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>http://localhost:1313/p/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/</guid>
        <description>&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;
&lt;h3 id=&#34;关系型数据库的三大范式&#34;&gt;关系型数据库的三大范式&lt;/h3&gt;
&lt;h4 id=&#34;1nf-第一范式&#34;&gt;1NF 第一范式&lt;/h4&gt;
&lt;p&gt;要求数据库表的每一列都是不可分割的原子数据项。&lt;/p&gt;
&lt;h4 id=&#34;2nf-第二范式&#34;&gt;2NF 第二范式&lt;/h4&gt;
&lt;p&gt;第二范式是在第一范式基础上面提出来的，也就是说满足第二范式意味同时满足了第一范式。&lt;/p&gt;
&lt;p&gt;凭（学号，课程号）可以决定成绩；但是凭学号就可以决定姓名，年龄和地址，不需要课程号。&lt;/p&gt;
&lt;p&gt;所以在这里尽管主键是（学号，课程号），但是姓名，年龄和地址只要学号就可以决定的，也就是说这三个属性对主键存在部分函数依赖，它只依赖于主键里面的学号这一项，只依赖于主键的一部分，所以不是第二范式。
&lt;img src=&#34;http://localhost:1313/image-2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;3nf-第三范式&#34;&gt;3NF 第三范式&lt;/h4&gt;
&lt;p&gt;在 2NF 基础上，不存在属性对主键的传递依赖。&lt;/p&gt;
&lt;p&gt;这张表的主键是员工号，一旦员工号确定了，工资级别也确定了，那么工资也就确定了。&lt;/p&gt;
&lt;p&gt;但是工资对员工号存在传递依赖&lt;/p&gt;
&lt;p&gt;具体看下图
&lt;img src=&#34;http://localhost:1313/image-3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;应当通过外键绑定员工与工资的关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际业务中，一般不使用数据库的外键功能，而是在代码中手动维护外键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://greenhathg.github.io/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;通俗理解数据库三大范式 | GreenHatHG の Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么-mysql-单表最多-2000w-行数据&#34;&gt;为什么 MySQL 单表最多 2000w 行数据？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;关于单表能存多少数据，阿里 JAVA 开发手册提出，建议最大 2000 万。&lt;/p&gt;
&lt;p&gt;然后也看过一篇文章，可以往单表塞 1 亿。&lt;/p&gt;
&lt;p&gt;但为什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这由 &lt;code&gt;MySQL&lt;/code&gt; 使用的 &lt;code&gt;InnoDB&lt;/code&gt; 引擎决定，在 &lt;code&gt;InnoDB&lt;/code&gt; 引擎中最小存储单元是页（&lt;code&gt;page&lt;/code&gt;），默认情况下页的大小为 &lt;code&gt;16KB&lt;/code&gt;，可以通过命令查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-MySQL&#34; data-lang=&#34;MySQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SHOW&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIKE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;innodb_page_size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- +------------------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- | Variable_name    | Value |
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- +------------------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- | innodb_page_size | 16384 |
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- +------------------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1 row in set (0.02 sec)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说 &lt;code&gt;InnoDB&lt;/code&gt; 的非叶子节点大小，默认情况是 &lt;code&gt;16KB&lt;/code&gt;，加上&lt;code&gt;B+&lt;/code&gt; 树的非叶子节点只存储主键值（&lt;code&gt;bigint&lt;/code&gt; 占用 &lt;code&gt;8Byte&lt;/code&gt;）和下一层的页地址（指针占用 &lt;code&gt;6Byte&lt;/code&gt;），那么一个非叶子节点能最多能存储 &lt;code&gt;16KB/14Byte = 1170&lt;/code&gt; 个页地址。
&lt;img src=&#34;http://localhost:1313/image-9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这时候就可以计算叶子节点的个数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$2$ 层 &lt;code&gt;B+&lt;/code&gt; 树，总有 $1170$ 个叶子节点&lt;/li&gt;
&lt;li&gt;$3$ 层 &lt;code&gt;B+&lt;/code&gt; 树，总有 $1170 * 1170 = 1368900$ 个叶子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在叶子节点中，默认大小也是 &lt;code&gt;16KB&lt;/code&gt;，结构如图所示：
&lt;img src=&#34;http://localhost:1313/image-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;那一页能留多少存储空间呢？&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;User Records&lt;/code&gt; 和 &lt;code&gt;Free Space&lt;/code&gt; 以外所占用的存储是 $38 + 56 + 26 + 8 = 128$。
当新记录插入到 &lt;code&gt;InnoDB&lt;/code&gt; 聚集索引中时，&lt;code&gt;InnoDB&lt;/code&gt; 会尝试留出 &lt;code&gt;1/16&lt;/code&gt; 的页面空闲以供将来插入和更新索引记录，所以就只剩下 &lt;code&gt;15/16&lt;/code&gt;。
因此可存储空间为：&lt;code&gt;15/16 * 1024 - 128 = 15232 Byte&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设每行数据平均占用 &lt;code&gt;1KB&lt;/code&gt;，那么一个叶子节点可以存储 &lt;code&gt;15232/1024 = 14.875&lt;/code&gt; 条数据，此时就可以计算 &lt;code&gt;B+&lt;/code&gt; 树最大存储数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$2$ 层 &lt;code&gt;B+&lt;/code&gt; 树，总有 $1170$ 个叶子节点，可以存储 $1170 * 14.875 = 17403.75$&lt;/li&gt;
&lt;li&gt;$3$ 层 &lt;code&gt;B+&lt;/code&gt; 树，总有 $1170 * 1170 = 1368900$ 个叶子节点，可以存储 $1170 * 1170 * 14.875 = 20362387.5$&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;参考资料-1&#34;&gt;参考资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/yifanSJ/p/17662132.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb引擎中B+树一般有几层？能容纳多少数据量？ - yifanSJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/read/cv28706559&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 单表可以放多少数据，最多 2000 万&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么-innodb-使用-b树-存储数据&#34;&gt;为什么 &lt;code&gt;InnoDb&lt;/code&gt; 使用 B+树 存储数据？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;要能高效地查询某一个记录，也要能高效地执行范围查找；&lt;/li&gt;
&lt;li&gt;能在尽可能少的磁盘的 I/O 操作中完成查询工作；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;什么数据结构支持高效的范围查询呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红黑树&lt;/li&gt;
&lt;li&gt;线段树
如果想高效的范围查询，那么数据的存储最好就是有序的&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>http://localhost:1313/p/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/</guid>
        <description>&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;h3 id=&#34;日志类型&#34;&gt;日志类型&lt;/h3&gt;
&lt;p&gt;MySQL 日志文件有很多，包括 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误日志（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。&lt;/li&gt;
&lt;li&gt;慢查询日志（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。&lt;/li&gt;
&lt;li&gt;一般查询日志（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。&lt;/li&gt;
&lt;li&gt;二进制日志（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有两个 InnoDB 存储引擎特有的日志文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重做日志（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。&lt;/li&gt;
&lt;li&gt;回滚日志（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新机制&#34;&gt;更新机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/image-4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
简单来说，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启事务标记&lt;/li&gt;
&lt;li&gt;执行更新操作&lt;/li&gt;
&lt;li&gt;结束事务标记&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>http://localhost:1313/p/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/</guid>
        <description>&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;h3 id=&#34;事务的四大特性&#34;&gt;事务的四大特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性
顾客在支付时，使用了 零钱 + 银行卡 组合支付，交易的结果就应该是要么都如数扣款，要么没有变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久性
数据只要没被操作，就不会发生变动，比如存钱，不考虑利息，只要不取不存，存款就不会变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离性
同时有多笔订单时，不会出现支付金额混乱的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性
数据在事务前后，数据不会被破坏，是三者同时生效时的结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
