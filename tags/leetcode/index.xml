<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 雾封的笔</title>
    <link>https://niluan304.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on 雾封的笔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>雾封 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Fri, 12 Jan 2024 17:52:09 +0800</lastBuildDate>
    <atom:link href="https://niluan304.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LC2522. 统计上升四元组</title>
      <link>https://niluan304.github.io/posts/lc2522.-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/</link>
      <pubDate>Fri, 12 Jan 2024 17:52:09 +0800</pubDate>
      <guid>https://niluan304.github.io/posts/lc2522.-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/</guid>
      <description>$132$ 模式的进阶，求 $1324$ 模式 的个数：枚举 4 ，求 4 左边 132 模式的数量&#xA;前言 四元上升组定义：一个组 $(i, j, k, l)$ 满足以下条件：&#xA;$0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; l &amp;lt; n $ 且 $nums[i] &amp;lt; nums[k] &amp;lt; nums[j] &amp;lt; nums[l] $。 在数组中是这样的：&#xA;这里称之为 $1324$ 模式，如果有疑惑，请先AC：456. 132 模式&#xA;AC后，可以先思考下：返回长度 $n-2$ 的数组，记录每个 $j$ 下有多少个 $132$ 模式。&#xA;$ nums[i] &amp;lt; nums[k] &amp;lt; nums[j] \quad \quad i&amp;lt;j&amp;lt;k $&#xA;解法的时间复杂度应当不超过 $\mathcal{O}(n^2)$&#xA;比如 示例3：$nums = [-1,3,2,0]$&#xA;$j=1$ 下有 $2$ 个 $132$ 模式的的子序列：$[-1, 3, 2]$、$[-1, 3, 0]$</description>
    </item>
    <item>
      <title>LC2681. 英雄的力量</title>
      <link>https://niluan304.github.io/posts/lc2681.-%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/</link>
      <pubDate>Sat, 06 Jan 2024 17:55:31 +0800</pubDate>
      <guid>https://niluan304.github.io/posts/lc2681.-%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/</guid>
      <description>记一次解题过程：通过观察猜到了递推公式&#xA;读题 根据「这组英雄的力量」的定义，得知元素顺序不影响答案，那么可以先排序，然后固定最大值。&#xA;暴力解法：全排列小于当前最大值的数，再遍历最小值，但是这种做法时间复杂度过高，没办法优化。&#xA;优化暴力解法，也是一种解题方法。&#xA;读题时有两点必须要注意到：&#xA;数据范围： $1 \leq nums.length \leq 10^5$，表明本题时间复杂度至多为 $\mathcal{O}(n\log n)$; 由于答案可能非常大，请你将结果对 $10^9 + 7$ 取余。 根据我以往的做题经验，猜测本题的解法是动态规划。&#xA;观察与猜测 没什么思路的时，我喜欢在草稿纸上写例子，比如有 $nums = [1,2,3,4,5]$，顺序从小到大。&#xA;以下思考过程是有问题的，因为按子序列个数的划分方式并不方便找到规律。&#xA;设当前最大值为 $a_n$，$[a_1,a_2,&amp;hellip;,a_n]$ 的全排列后的最小值之和为 $S_n$，那么答案为：$\sum{a_n^2 * S_n}$&#xA;$a_1 = 1, S_1 = [1]$&#xA;$a_2=2, S_2 = [ 2 + (1)]$&#xA;解释：只有 $1$ 个数时：$\sum\min{[2]} = 2$，$2$ 个数时：$\sum\min{[2,1]} = 1$ $a_3 = 3, S_3 = [3 + (2+1) + (1)]$&#xA;解释：只有 $1$ 个数时：$\sum\min{[3]} = 3$，$2$ 个数时：$\sum\min{[3,2]} + \sum\min{[3,1]} = 2 + 1$，$3$ 个数：$\sum\min{[3,2,1]} = 1$ $a_4 = 4, S_4 = [4 + (3+2+1) + (2+1+1) + (1)]$</description>
    </item>
    <item>
      <title>LC70. 从爬楼梯上手动态规划</title>
      <link>https://niluan304.github.io/posts/lc70.-%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Thu, 21 Sep 2023 16:54:07 +0800</pubDate>
      <guid>https://niluan304.github.io/posts/lc70.-%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>将简单难度的题目拓展到中等难度&#xA;动态规划入门：递归 本题 70. 爬楼梯 是非常经典的动态规划入门题，动态规划的核心是找到状态转移方程：当前状态与之前状态的关系。想要找到方程，通常需要我们用自顶向下的方式去思考问题，将一个大问题转化为解决子问题，实现的手段通常为递归。&#xA;读题：&#xA;每次可以爬 $1$ 或 $2$ 阶； 一共要爬 $n$ 阶； 问爬到 $n$ 阶有多少种方法？ 假设当前处于第 $n$ 阶，问：上一步处于哪个阶梯？&#xA;答：处于 $n-1$ 或 $n-2$ 阶。因为每次只能爬 $1$ 阶或 $2$ 阶，那么上一步选择爬 $1$ 阶，就会处于 $n-1$ 阶，选择爬 $2$ 阶，就会处于 $n-2$ 阶。&#xA;解题思路：&#xA;记 $f(n)$ 为爬到 $n$ 阶的方法数，如果知道了 $f(n-1)$ 和 $f(n-2)$ ，两者相加就能得到 $f(n)$ ，即 $f(n) = f(n-1) + f(n-2)$ 。&#xA;那又如何求 $f(n-1)$ 和 $f(n-2)$ 呢？令 $n = n-1$ ，就有 $f(n-1) = f(n-2) + f(n-3)$ ，可以发现，解决的手段就是递归。</description>
    </item>
  </channel>
</rss>
